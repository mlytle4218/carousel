/*! Mon Oct 01 2018 12:02:30 */

var container,inter,camera,scene,renderer,light,imagesArray,rotationRate=-.005,speed=0,radius=10,cameraDistance=35,quickZoom=35,mouseDown=!1,mouseOver=!1,timeStamp=null,prevMouseX=null,prevMouseY=null,averageX=[0,0],averageY=[0,0],raycaster=new THREE.Raycaster,mouse=new THREE.Vector2,connectingElement="carousel",ambientLightColor=16777215;function start(e){container=document.getElementById(connectingElement),initCar(imagesArray=createImagePlanes(e)),animateCar(),window.addEventListener("mousedown",onMouseDown,!1),window.addEventListener("mouseup",onMouseUp,!1),window.addEventListener("mousemove",onMouseMove,!1),window.addEventListener("mouseover",onMouseOver,!1),window.addEventListener("mouseout",onMouseOff,!1)}function createImagePlanes(e){var r=[],n=[];return e.files.forEach(function(e){n.push(e.pic)}),e.files.forEach(function(e){var n=new THREE.TextureLoader,t=new THREE.MeshLambertMaterial({map:n.load(e.pic)});t.transparent=!0;var o=new THREE.PlaneGeometry(15,15),a=new THREE.Mesh(o,t);a.position.set(0,-3,0),a.url=e.url,r.push(a)}),r}function loadObjModel(a){var r;return new Promise(function(t,o){var e=new THREE.MTLLoader;e.setPath(a),e.load(name+".mtl",function(e){e.preload();var n=new THREE.OBJLoader;n.setMaterials(e),n.setPath(a),n.load(name+".obj",t,r,o)},r,o)})}function initCar(e){(camera=new THREE.PerspectiveCamera(45,container.clientWidth/container.clientHeight,1,100)).position.set(0,-2,cameraDistance),mouse=new THREE.Vector2,scene=new THREE.Scene,(light=new THREE.AmbientLight(ambientLightColor)).position.set(0,10,0),scene.add(light),parent=new THREE.Object3D,scene.add(parent);for(var n=0,t=0;t<e.length;t++){var o=new THREE.Object3D;o.rotation.y=n*Math.PI/e.length,parent.add(o),e[t].position.z=15,e[t].rotation.y=-n*Math.PI/e.length,o.add(e[t]),n+=2}this.renderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0}),renderer.setPixelRatio(window.devicePixelRatio),renderer.setSize(container.clientWidth,container.clientHeight),renderer.gammaOutput=!0,container.appendChild(renderer.domElement)}function myLoader(e){var t,o=Math.floor(100/e.length),a=0;return e.forEach(function(n){var e=new THREE.TextureLoader;new THREE.MeshLambertMaterial({map:e.load(n,function(e){a+=o,console.log(a+"% loaded"),t.push(n)},function(){console.log("progress")})})}),t}function onWindowResize(){camera.aspect=container.clientWidth/container.clientHeight,camera.updateProjectionMatrix(),renderer.setSize(container.clientWidth,container.clientHeight)}function animateCar(){requestAnimationFrame(animateCar),renderer.render(scene,camera),(speed<1e-4||1e-4<speed)&&(speed*=.99),rotateParent(mouseOver?getRotationRate()/2:getRotationRate())}function onMouseDown(e){if(inContainer(e)){mouseDown=!0,averageX=[0,0],averageY=[0,0],e.preventDefault(),raycaster.setFromCamera(mouse,camera);var n=raycaster.intersectObjects(scene.children,!0);0<n.length&&(inter=n[0])}}function onMouseUp(e){mouseDown=!1}function onMouseMove(e){if(mouseDown&inContainer(e)){if(null===timeStamp)return timeStamp=Date.now(),prevMouseX=e.clientX,void(prevMouseY=e.clientY);var n=Date.now(),t=n-timeStamp,o=e.clientX-prevMouseX,a=e.clientY-prevMouseY,r=Math.round(o/t*100),i=(Math.round(a/t*100),Math.floor(container.clientWidth/6)+container.offsetLeft),c=4*Math.floor(container.clientWidth/6)+container.offsetLeft+i;if(e.clientX>i&e.clientX<c)if(0<o)rotateParent((e.clientX-i)/(4*Math.floor(container.clientWidth/6))*(Math.PI/180));else rotateParent(-((container.clientWidth-e.clientX-i)/(4*Math.floor(container.clientWidth/6)))*(Math.PI/180));mouse.x=e.clientX/window.innerWidth*2-1,mouse.y=-e.clientY/window.innerHeight*2+1,averageX[0]+=r,averageX[1]++,timeStamp=n,prevMouseX=e.clientX,prevMouseY=e.clientY,(speed=averageX[0]/averageX[1]/1e3*.1)*rotationRate<0&&(rotationRate*=-1)}}function rotateParent(e){parent.rotation.y+=e;for(var n=0;n<parent.children.length;n++)parent.children[n].children[0].rotation.y+=-e}function toRadians(e){return e*(Math.PI/180)}function onMouseOver(e){mouseOver=!!inContainer(e)}function inContainer(e){return!!(e.clientX>container.offsetLeft&e.clientX<container.offsetLeft+container.clientWidth&&e.clientY>container.offsetTop&e.clientY<container.offsetTop+container.clientHeight)}function onMouseOff(e){mouseOver=!1}function getRotationRate(){return mouseDown?0:speed*rotationRate<0?-rotationRate+speed:rotationRate+speed}window.addEventListener("resize",onWindowResize,!1);